
一个系统不是一下子就能设计的非常完美，在有限资源情况下，一定要先解决当下最核心的问题，预测未来的问题，迭代推进。
一句话：对现有问题有方案，对未来架构有预案。

大型网站(访问量、业务复杂度、数据量)优化：
（从系统架构、代码、数据库）

1.业务拆分：模块解耦；分布式部署、避免服务雪崩；区分核心与非核心，高并发下降级
  核心功能：机票、火车票、酒店、财务、crm、oa 、
  非核心功能：客服、评论、支付(2B使用)
   
2.服务部署：
  第一种：分布式 ---->集群 rancher /k8s
  第二种：api网关---->etcd服务负载
分布式部署：每一个模块服务单独docker部署,分布式服务有三种状态：
成功、失败、超时(请求或相应)

3.缓存 ：可抗大流量的银弹
 客户端：浏览器端缓存和app客户端缓存(js\css\images)
CDN：最近节点找相要的数据
应用层缓存：(后端缓存或分布式缓存)：redis


4.db 拆分：解决容量和性能的问题
分库、分表(阿里 Mycat):一般按照订单id进行拆分
数据异构( join)：将多个数据源拿过来(通过MQ)，一般放到redis或者kv存储中。
数据聚合：将多个数据源的数据做个聚合，返回给前端。
  以mysql为例：
  采用 订阅数据库变更日志，比如订阅mysql的binlog日志模拟数据库的主从同步机制，然后解析变更日志写到订单列表，从而实现数据异构。
https://github.com/alibaba/canal


5.消息队列：解决模块耦合，异步、高可用。（nsq）
 下单后----nsq---库存减少、支付、财务结算

高可用方式：
缓存：抗流量的银弹
降级：对抗高并发流量，通过配置、同步改异步、暂时停掉非核心功能，保证核心功能
限流：秒杀、抢购、恶意请求，使用令牌桶算法、计数器
可回滚：事务、代码、数据库回滚
隔离：故障隔离
超时与重试：设置合理的超时时间和重试次数
压测：whr 


业界高可用的标准是按照系统宕机时间来衡量的：
基本可以2个9,87.9h--->6个9，31s 最高6个9
因为业界的标准是后验的指标，考虑到对于平时工作的指导意义，我们通常采用服务治理平台OCTO来统计可用性。计算方法是：
服务可用性=成功调用数/调用总数
成功调用数=调用总数-失败总数




总结： 别人死我们不死，自己不作死，不被队友搞死。


1.别人死我们不死：无依赖，
要是有依赖就去依赖，去不了，就弱依赖，如果要强依赖，那就容灾。
容灾：别人死了，我们快速失败，安全提示，
    别人活了，快速恢复：心跳检查 或者 事件监听
需要设置合理超时和重试、蓄洪、限流、熔断、降级


2.自己不作死：
不作：不当小白鼠，用成熟的技术；规范研发流程、做好测试和演练
不死：单个节点挂了，用集群；单个机房挂了，用多机房；整个地区网断，用多机房；即：异地多活
涉及到集群和跨区的要有策略：负载均衡、主从切换，优先策略

阿里异地多活三个阶段：同城多活--异地只读和冷备--异地多活

3.不被队友搞死：
队友：部门内部依赖关系
需要明确边界，做到队友死自己不死。


一句话：研发规范、自身稳定、容错下游、防御上游。




reference:
https://www.cnblogs.com/xiexj/p/8495148.html
开涛搭建高可用高并发系统
https://www.cnblogs.com/xiexj/p/8886356.html
