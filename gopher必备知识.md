前言：一个问题的解决方案，是在某一个历史时期的某一个场景下的最优解，随着时间的推移，新的技术产生，问题解决方案也就多样化了。

具备的知识分类：
1.通用问题
2.开放式问题
3.设计模式
4.代码相关
5.语言相关
6.web相关
7.数据库相关
8.并发问题
9.分布式问题
10.软件生命周期和团队管理
11.逻辑和算法
12.软件架构（SOA、微服务）
13.安全相关问题

第一通用问题：
1.面向对象编程 vs 函数式编程区别？
  OOP:以对象为中心；函数式对象，用于逻辑处理，符合人认知方式和思考方式：函数是第一公民；语法简洁，多用于数据处理
2.微软、谷歌、欧朋(opera)和火狐这类公司是如何从他们的浏览器中获利的？
浏览器是一个流量入口为网站/搜索引擎；广告；推送服务；推荐软件安装
3.语言设计中空引用(null reference)的存在有什么问题？假设你想要将空引用的概念从你的首选语言中移除，可能导致什么结果？
 比如c#语言，导致未将对象引用为对象实例，Golang:初始化默认的值；如果移除，默认值是一个需要考虑的问题
4.为什么打开TCP套接字有很大的开销？
三次握手，四次挥手；每次一个客户端连接，都要fork一个进程
5. 封装的重要性体现在哪儿？
 在面向对象编程中，对内部成员变量、函数一种信息隐藏，“高内聚”体现，于其它模块隔离；在编写函数、方法、API是，封装利于可复用性
6.什么是实时系统？它与普通系统有什么区别？
 实时操作系统：对外部请求及时响应，响应时间是最重要的指标，例如 vsWorks, 军工、航天工业上应用、汽车安全气囊、导弹发射器，
 非实时操作系统：目前用的Linux Windows 
7.实时语言和堆内存分配之间的关系是什么？
  堆:程序员 new/make 分配并手动回收或者GC回收，栈：局部变量、参数使用，先进后出。
8.什么是O/R阻抗失衡,与ORMapping关系？
 ORM:面向对象描述业务，关系型数控管理数据的存储，面向对象的对象模型和关系型数据库的数据结构之间的相互转换。
 O/R阻抗失衡(O/R Impedance Mismatch)：指的是OO对象模型和关系型数据库的数据结构之间的，设计理念上的差异。
 OO专家认为业务是最重要的，数据服务与业务。遵循SOLID原则
 数据库专家认为数据是一个公司财富，保证数据的稳定性。
 最终：两者需要相辅相成，oo 常规使用一对一，一对多关心 去映射db.
 9.缓存的使用场景及注意事项？
 根据业务特点，明确容易变，哪些不容易变，即：读多写少的应用场景。
 更新缓存还是删除缓存，取决于业务的复杂度，如果获取用户常旅客信息，两者都很简单。
 执行写操作：先淘汰缓存，再写数据库，原因：减少对业务的影响为原则。
 缓存架构设计：常规做法，api 接入，先访问cache，再访问db;另一种做法：写走db,读走cache，db和cache做异步同步。
 10.TCP/IP和HTTP有什么区别？
 http 应用层，负责用户UI，依赖于tcp传输层，保证数据可靠有序的传输，tcp依赖于ip,ip网络地址，提供端到端的传输
 11.在客户端渲染(client-side rendering)和服务端渲染(server-side rendering)之间，你是如何权衡的？
    前端渲染：后端返回json,前端加载css\js ,渲染模板，加载相对后端渲染慢，SEO差，编码效率高，前后端各司其职。
    后端渲染：后端直接生成html,前端显示，加载速度快，SEO效果好,前后端代码混合，可维护性不好，占有服务端资源
    自己选择：根据业务，需要快速响应，不涉及页面交互的，后端来做，其它交给前端。
12.如何在一个不可靠的协议之上构建一个可靠的通信协议？
 必须保证接收方的应用收到了完整且正确的数据，这种服务就是可靠数据传输服务。
 tcp协议:TCP是一种面向连接的、可靠的、基于字节流的运输层（Transport layer）通信协议。
   三次握手最大程度上保证了连接的可靠性，通过数据校验保证发送和接收到的数据是有序的，一致的，四次挥手关闭连接。
 udp协议：无连接的协议。不保证传输数据的可靠性，、单向推送、不可靠、，最大的优点传输快，应用包括TFTP ,  SNMP , DNS ,DHCP等。
 
 TCP如何提供可靠性，表现在以下几个方面：
 
在传输过程中，通信双方的协议模块继续进行通信，从而确保了传输的可靠性。
针对乱序：在通过三次握手进行链接时，序列号被初始化，表示哪些数据传输哪些数据没有传输。
针对丢包：在传输过程中，接收方收到一个数据段后，会用ACK应答码向发送端回复一个IP包进行应答是否接收。
针对重复：接收端收到数据段后，查看序列号，如果已经成功接收改数据包，则丢弃后面这个数据段。
针对延时：延时造成的第一个问题，就是数据包达到接收端时乱序。


TCP中，序列号和ACK应答号有哪些作用？

依靠序列号重组数据段
依靠数据包消除网络中的重复包
依靠序列号和应答号进行差错重传，提高了TCP的可靠性
当延时严重时，接收端一直未收到数据段，则不会回复ACK，发送端认为丢包，重发。
 
 
第二开放式问题：
1.当操作系统CPU处于空闲的时候，它可能在处理哪些事情？
 当CPU空闲时，调度程序从内存中的就绪进程中选取一个进程，分配给cpu.
 没有可供运行的进程时，就开始运行空闲任务(idle tasks)，另外大部分芯片设计的一个目标是将处理器尽快地切换到低功率状态。
2.如何维护单体架构?
 遵循开闭原则，对内修改关闭，增加对外的扩展，使用适配器模式、代理模式
 面向接口原则，降低系统耦合度
 迪米特法则，一个对象应该对其他对象保持最少的了解，降低复杂度，提供可维护性。


第三设计模式：
1.全局变量劣势？
全局变量优点：
     .全局可视，任何一个函数都可以访问和更改变量值；.内存地址固定，读写效率高
全局变量缺点：
    多核多线程情况下，引发竞态条件。
 2.好莱坞原则?
    别调用我们，我们会调用你。拒绝低层组件调用高层组件，而是等待高层组件来调用低层组件，这样可以降低编程的复杂程度
 3.迪米特原则？
    当类A需要调用另一个非直接相联系的类(类C)的方法时，可以通过friend类(类B)调用类C的方法，然后类A再调用其friend类(类B)中的相应的方法。
    如果A直接调用C,则违反了迪米特原则。
 4.Active-Record模式有什么限制和缺陷？
   Active Record(活动记录模式) 是一种数据访问设计模式，它可以帮助你实现数据对象Object到关系数据库的映射。每一个类的实例对象唯一对应一个数据库表的一行(一对一关系)，
   对单个表使用简单，对于关联表，类继承关系较为复杂问题比较多。
   Data Mapper（数据映射模式）则是将领域模型对象和数据表完全松耦合，不用与数据库字段一一对应。领域模式关注业务逻辑，不知道数据层，与数据层解耦。
   使用实体管理器的对象持久化到数据库。
 5.空对象模式(Null Object Pattern)的目的是什么？
   加强系统的稳固性，能有有效地防止空指针报错对整个系统的影响，不要客户端做判断。
 6.单例模式 线程安全及线程不安全两种？
 线程安全：使用 sync.Once
 package main

import (
	"fmt"
	"sync"
)

type singleton struct {
	No string
}

var instance *singleton
var once sync.Once

func GetInstance() *singleton {
	once.Do(func() {
		instance = &singleton{No: "i am the first!"}
	})
	return instance
}
func (s *singleton) Test() {
	fmt.Println(s.No)
}
func main() {
	s := GetInstance()
	s.Test()
}

线程不安全：
func GetInstance() *singleton {
    if instance == nil {
        instance = &singleton{}   //危险之处
    }
    return instance
}

第四 代码相关：
1.设计和架构有什么区别
架构更宏观一些，决定各个系统之间模块、架构、语言、db等。比如MVC就是一种架构模式。
而设计模式就具体多了，它关注的是接口/类之间的关系。
没有架构，楼很难建造
但没有设计模式，不影响建造，只是工人做着很难受。
2.类单继承和接口多继承理解？
 C#、Java 类不支持多重继承的主要原因是，如果A同时继承B和C，而B和C同时有一个funcA方法，A不知道该使用谁的funcA方法，支持单继承，单继承： 易维护 语义清晰 逻辑清楚。
  但接口不存在这样的问题，接口全都是抽象方法继承谁都无所谓，所以接口可以继承多个接口。
3.存储过程（Stored Procedures）中写业务逻辑有什么优缺点
 优点：执行效率高，
 缺点：代码可扩展性差、不易调试
 是否使用：取决于系统规模、产品方向，是否经常变动业务

第五 语言相关
1.谈谈函数式编程
 函数式编程：本质数学问题，将一个实际问题转换成数学模型，然后通过计算机语言编写出来，应用在数学性、并发性问题上。
 面向对象编程：抽象成一个对象，然后去做；抽象的过程为了代码复用，所有会带来一些用不到的代码，应用在业务系统crud.
 
 第六 Web相关
 
 第七 数据库相关
 1.mysql 迁移pg
 mysql2pg:https://github.com/the4thdoctor/pg_chameleon
 pg2mysql:https://github.com/pivotal-cf/pg2mysql
 2.为什么SELECT * FROM table WHERE field = null不能匹配空的字段？ 
  db中空值(null)与空字符('') 不同，
  null :应该使用：where field is null / is not null ，mysql3.23支持 <> null
  '' ：应该使用 where field == '' / <>''
 3.关系型db的ACID 及非关系db CAP和最终一致性原则的理解？
 关系型db:采用关系模式、主外键的关联的二维表，支持事务，遵循ACID原则，支持sql，利于复杂查询，但在高并发、海量数据的读写性能较差。
 ACID：Atomic原子性要么成功要么失败；Consistent一致性:业务的一致性,所有操作符合当时期望；Isolated隔离性并发时数据隔离处理，互不影响；Durable持久性数据一旦提交持久存在
 非关系型db:采用键值对存储，实际是一个数据结构，不支持ACID，使用分布式方案处理，遵循CAP原则，不用经过sql解析，读写性能高，但不支持事务。
 CAP:Consistent一致性分布式系统中所有地方的 数据一致性；Available可用性 每一个节点都可以使用；Partition Tolerant分区容错性两处数据复制时，发送错误有容错方案。
 分布式事务：遵循CAP，数据一致性，区别于ACID一致性，在于这里指数据的一致性：分为 强一致性 弱一致性及最终的一致性(dns).
 4.追加版本管理的问题
  git比svn哪些优势、劣势？
  git:分布式的，没有网络的情况下也可以提交到本地仓库，速度快,存储的是元数据。
  svn:不是分布式的，没有网络不能使用，速度慢，存储数据是文件内容，使用相对简单，存放sd文档可以。
 
 第八 并发问题
 1.为什么需要并发？
  并发应用场景：1.响应用户请求，一方面UI，另一方面大量运算、io密集操作 2.web服务器大量用户请求时 3.cup 由单核到多核，但我们程序是串行的，不能充分发挥计算机硬件能力
  并发优势：1.增强用户体验 2.充分利用cpu多核，提高程序执行效率

2.死锁，活锁和饥饿理解：
死锁：是指两个或两个以上的进程（或线程）在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。例如：2辆车在一条路上，互不让行
活锁：是指线程1可以使用资源，但它很礼貌，让其他线程先使用资源，线程2也可以使用资源，但它很绅士，也让其他线程先使用资源。这样你让我，我让你，最后两个线程都无法使用资源。例如：2辆车在一条路上，互相让行
饥饿：是指如果线程T1占用了资源R，线程T2又请求封锁R，于是T2等待。T3也请求资源R，当T1释放了R上的封锁后，系统首先批准了T3的请求，T2仍然等待。然后T4又请求封锁R，当T3释放了R上的封锁之后，系统又批准了T4的请求......，T2可能永远等待
     例如：交警指挥四个方向来车，先让三方走，另一方持续等待
3.Lock-free VS wait-free ？
无锁系统是相对于多个线程来说的，当其中一个线程阻塞的时候，其他线程可以继续运行，相互不影响。案例：RethinkDB
无等待系统更像是针对一个线程来说的，该线程在运行过程中不会被任何运算所阻塞。案例：Linux kernel的无锁页面缓存

第九分布式问题：
1.远程过程调用的通用缺点是什么？既然有http 请求，为什么还要用rpc调用？
通俗的讲：
http好比普通话，rpc好比团伙内部黑话。
讲普通话，好处就是谁都听得懂，谁都会讲。
讲黑话，好处是可以更精简、更加保密、更高效、可定制，坏处就是要求“说”黑话的那一方（client端）也要懂，而且一旦大家都说一种黑话了，换黑话就困难了。

应用场景：对内部rpc使用grpc 二进制传输，相比http json 序列化、反序列化大大提高了传输速率， 对外 http 。
rpc最关键的地方有请求体的封装，响应体的封装以及客户端调用的封装。
RPC是一种编程模式，把对服务器的调用抽象为过程调用，通常还伴随着框架代码自动生成等功能。
使用RPC做网络服务开发时，通常只需要实现服务器端的一个处理函数，其余的客户端调用，序列化反序列化，方法派发（收到什么样的消息，调用服务器端的什么函数）等都由框架或者生成的代码来完成，
较大地减轻了网络服务开发和调用的复杂性。
HTTP是一种应用层网络协议，RPC可以采用自定义协议，也可以通过HTTP协议来传输，thrift，grpc，xml-rpc，json-rpc都是通过HTTP传输的。
HTTP既支持长连接，也支持短连接。

rpc是远程过程调用，其调用协议通常包含传输协议和编码协议。
传输协议包含: 如著名的 [gRPC](grpc / grpc.io) 使用的 http2 协议，也有如dubbo一类的自定义报文的tcp协议。
编码协议包含: 如基于文本编码的 xml json，也有二进制编码的 protobuf binpack 等。
为什么要使用自定义 tcp 协议的 rpc 做后端进程通信？
要解决这个问题就应该搞清楚 http 使用的 tcp 协议，
和我们自定义的 tcp 协议在报文上的区别。
  首先要否认一点 http 协议相较于自定义tcp报文协议，增加的开销在于连接的建立与断开。http协议是支持连接池复用的，也就是建立一定数量的连接不断开，并不会频繁的创建和销毁连接。
  其次要说的是http也可以使用protobuf这种二进制编码协议对内容进行编码，
  因此二者最大的区别还是在传输协议上。通用定义的http1.1协议的tcp报文包含太多废信息，报文元数据就是header头的键值对却用了文本编码，非常占字节数。
  
 2.在分布式系统中，面临的问题及如何处理？
  a.最突出问题：分布式事务问题例如：订单与库存|转账|同步、异步调用超时|数据库和缓存|上下游订单丢单
  采取方案： 事后补偿、最终的一致性(mq\nsq)、查询模式：操作成功还是需要回滚、定时校对
  b.负载均衡：分布式部署，一个请求来了，根据路由算法路由到哪一台服务器？如果是异地多活的多机房，根据session或者cookie路由到同机房服务。
  c.服务发现：服务的提供者如何被服务的使用者发现，当然很多情况一个服务既是某些服务的提供者，也是其他服务的使用者，
     这就需要一个中间的机制来让大家互相感知？如：高可用的ZK成为一个服务的订阅与通知的中心
  d.数据库高可用：高可用：主从机制或者异地机房 本质上都是冗余。扩容是在负载过高，收到警告后自动转移。
  
 
 3.网络分裂(network partitions)后有的几种恢复的方法？
  一种在系统的任何两个组之间的所有网络连接同时发生故障后所出现的情况。
  发生这种情况时，分裂的系统双方都会从对方一侧重新启动应用程序，进而导致重复服务或裂脑。
  如果一个群集中配置的两个独立系统具有对指定资源（通常是文件系统或卷）的独占访问权限，则会发生裂脑情况。
  由网络分裂造成的最为严重的问题是它会影响共享磁盘上的数据。
  恢复方式：todo
  
 4.分布式计算中有哪些谬论？
 八大谬论：
The network is reliable:网络是不可靠的，网络抖动，需要重试机制、幂等
Latency is zero：
Bandwidth is infinite.
The network is secure.
Topology doesn't change.
There is one administrator.
Transport cost is zero.
The network is homogeneous

5.你在什么时候会使用Request/Response模式，什么时候使用Publish/Subscribe模式？

第十 软件生命周期和团队管理相关问题：


reference：
https://www.jianshu.com/p/56e9f83fdd06
https://baike.baidu.com/item/Network%20Partition/8720737?fr=aladdin
http://blog.csdn.net/micro_hz/article/details/78632108
https://www.zhihu.com/question/41609070
http://blog.csdn.net/java_4_ever/article/details/42489499
http://blog.csdn.net/sigangjun/article/details/47786333
http://blog.csdn.net/code_thinking/article/details/41744875
http://blog.csdn.net/pg_roger/article/details/22066025
https://www.zhihu.com/question/67846139?utm_source=wechat_session&utm_medium=social
http://blog.csdn.net/nszkadrgg/article/details/8471679
https://www.zhihu.com/question/39324847