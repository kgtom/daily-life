## 学习大纲
* [一、概况](#1)
* [二、限流算法](#2)
* [三、应用级限流](#3)
* [四、分布式限流](#4)
* [五、接入层限流](#5)

## <span id="1">一、概况</span>
 在开发高并发系统时，有很大手段来保护系统。例如：缓存、降级、限流。
 * 缓存：提升系统访问速度和增大系统处理能力，抗高并发的银弹
 * 降级：当服务出现问题，影响到核心服务时，需要暂时屏蔽掉。
 * 限流：有些场景不能用缓存和降级来处理，比如：秒杀、抢购。需要用一种手段来限制这种场景下的并发/请求量。
 
 一般高并发系统常见的限流：
 * 限制总并发，例如：数据库连接池、线程池
 * 限制瞬时并发，例如：Nginx limit_conn
 * 限制时间窗口内的平均速率，例如： Nginx limit_req
 * 限制远程窗口/MQ的调用速率：例如：redis 
 
 两大利器：缓存+限流 保证系统高并发。
 不用一味追求最佳模式，有时候不管黑猫白猫，解决问题就是好猫。
 
 ## <span id="2">二、限流算法</span>

常见限流算法：令牌通、漏桶、计数器。
### 1.令牌桶算法
固定容量的令牌，按照固定速率，往桶里加令牌。

### 2.漏桶算法
固定容量漏桶，按照常量固定速率流出请求。

### 3.简单粗暴---计数器

## <span id="3">三、应用级限流</span>
### 1. 限流总并发、连接数、请求数
 通过测试设置合理的并发数。场景：mysql 、redis 都会默认设置连接数。
### 2.限流总资源
 采用job/worker线程池模式，设置线程池大小。
### 3.限流某个接口的总并发、总请求数
简单粗博方法，计数器统计次数,if 次数>限流数 则拒绝访问，如秒杀抢购，要么排队、要么告知没有货了。
### 4.限流某个接口的时间窗(秒、分、时)请求数
将请求秒数、分钟、小时作为key，写入redis。统计没有秒、分钟、小时请求。
~~~java
long limitCount=2000
currentSec=System.currentTimeMillis()/1000;
if(GetRedis(currentSec)>2000){

 System.out.println("触发限流");
 contine;
}else{

//业务处理

}
~~~

### 5.平滑限流某个接口的请求数
使用令牌通算法即可。



## <span id="4">四、分布式限流</span>
### 1.Redis+Lua实现

### 2.Nginx+Lua实现


## <span id="5">五、接入层限流</span>
接入层通常指请求流量的入口，该层的主要目的有：负载均衡、非法请求过滤、求聚合、缓存、降级、限流、A/B测试、服务质量监控。

对于Nginx限流可以使用：ngx_http_limit_conn_module和漏桶算法实现限流模块 ngx_http_limit_req_module。

### 1.ngx_http_limit_conn_module


### 2.ngx_http_limit_req_module

>Reference

* 开涛's《亿级流量网站架构核心技术》
