## 学习大纲
* [一、概况](#1)
* [二、线程隔离](#2)
* [三、进程隔离](#3)
* [四、集群隔离](#4)
* [五、机房隔离](#5)
* [六、读写隔离](#6)
* [七、动静隔离](#7)
* [八、爬虫隔离](#8)
* [九、热点隔离](#9)
* [十、资源隔离](#10)

## <span id="1">一、概况</span>
隔离是指发生故障后，不会出现滚雪球效应，从而保证其它服务是可用的，出问题的不可用。隔离方式很多种，具体如下：

## <span id="2">二、线程隔离</span>
### 1.思路
线程隔离主要指线程池隔离，在实际使用时，我们会把请求分类，然后交给不同线程池处理，当一种业务请求处理发生问题，不会将故障扩散到其他线程池，从而保证其它服务可用。
### 2.具体做法
根据业务等级划分不同线程池。
* 核心业务使用 level1 线程池
* 非核心业务使用 level2 线程池
### 3.golang线程池
  golang 没有线程的概念，使用goroutine处理请求。
  * 在go1.5之前，默认单核cpu情况下，go所有的goroutines在一个线程里面跑,goroutine依次串行执行，遵循goroutine是一个简单执行体，自生自灭，除非手动调用runtime调度，否则一直占用cpu。如果其中一个goroutine发生堵塞，则整个线程就堵塞了。
  * go1.5之后，默认开启多核cpu,一个goroutine堵塞，调度器会将该goroutine及与之处于同一个线程上的其他goroutines转移到新的线程上。保证goroutines不会堵塞。
  * golang线程池具体做法
   - 1.使用channel接收请求，开启一个或多个goroutine处理请求 ，这种做法容易发生堵塞
   - 2.每一个请求开启一个goroutine,请求处理完后释放掉。虽然goroutine是轻量级，但是开启过多，加之调度器调度及gc,也会有性能问题
  
## <span id="3">三、进程隔离</span>
 ### 1.发现问题(初创公司技术走势)
公司发展初期，考虑成本及团队能力，一般不会进行系统拆分，所以形成大而全的系统，之后随着规模增大，继而选择 部署多个站点，前面有Nginx负载。这只是一个过渡方案。
因为大而全系统如果一个模块出现bug,整个系统都瘫痪了。所以，如何解决呢？如下：
### 2.解决问题
 将系统模块拆分子系统进行物理隔离，从而某个子系统进程出现问题，不影响其它模块。
 
 客户端--->web =====>> 客户端--->Nginx--->多个web ======>> 客户端--->Nginx--->(crm、oa、order、supplier等)
 ## <span id="4">四、集群隔离</span>
 

>Reference

* 开涛's《亿级流量网站架构核心技术》
