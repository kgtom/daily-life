## 学习大纲
* [一、概况](#1)
* [二、线程隔离](#2)
* [三、进程隔离](#3)
* [四、集群隔离](#4)
* [五、机房隔离](#5)
* [六、读写隔离](#6)
* [七、动静隔离](#7)
* [八、爬虫隔离](#8)
* [九、热点隔离](#9)
* [十、资源隔离](#10)

## <span id="1">一、概况</span>
隔离是指发生故障后，不会出现滚雪球效应，从而保证其它服务是可用的，出问题的不可用。隔离方式很多种，具体如下：

## <span id="2">二、线程隔离</span>
### 1.思路
线程隔离主要指线程池隔离，在实际使用时，我们会把请求分类，然后交给不同线程池处理，当一种业务请求处理发生问题，不会将故障扩散到其他线程池，从而保证其它服务可用。
### 2.具体做法
根据业务等级划分不同线程池。
* 核心业务使用 level1 线程池
* 非核心业务使用 level2 线程池
### 3.golang“线程池”
`
golang没有线程的概念，使用goroutine处理请求。
golang特点原生支持并发，一种CSP并发模型(提倡不通过共享内存来通信，通过通信来共享内存)。golang并发是用户态"线程"(goroutine),相对os线程，轻量级的，可以实现几万并发逻辑。
`

 
  * 在go1.5之前，默认单核cpu情况下，go所有的goroutines在一个线程里面跑,goroutine依次串行执行，遵循goroutine是一个简单执行体，自生自灭，除非手动调用runtime调度，否则一直占用cpu。如果其中一个goroutine发生堵塞，则整个线程就堵塞了。
  * go1.5之后，默认开启多核cpu,一个goroutine堵塞，调度器会将该goroutine及与之处于同一个线程上的其他goroutines转移到新的线程上。保证goroutines不会堵塞。
  * golang“线程池”几种做法：
   - 1.简单粗暴做法：直接使用goroutine，每一个请求开启一个goroutine,请求处理完后释放掉。虽然goroutine是轻量级，但是没法控制开启数量，加之调度器调度及gc，导致内存暴涨,处理请求能力下降甚至程序崩溃。
   - 2.相对优雅做法：使用带缓冲channel+goroutine，使用channel接收请求，开启一个或多个goroutine处理请求,一定程度上缓解高并发，但是当请求速度大于请求处理的速度，缓冲区打满，后面请求堵塞了。
   - 3.真正有控制力法(工作池)：job队列+工作池，worker池来限制goroutine最大数量，每次来一个job,找一个worker去处理。

[详见](http://39.106.173.209:88/goroutine-asyn/)

## <span id="3">三、进程隔离</span>
 ### 1.发现问题(初创公司技术走势)
公司发展初期，考虑成本及团队能力，一般不会进行系统拆分，所以形成大而全的系统，之后随着规模增大，继而选择 部署多个站点，前面有Nginx负载。这只是一个过渡方案。
因为大而全系统如果一个模块出现bug,整个系统都瘫痪了。所以，如何解决呢？如下：
### 2.解决问题
 将系统模块拆分子系统进行物理隔离，从而某个子系统进程出现问题，不影响其它模块。
 
 客户端--->web =====>> 客户端--->Nginx--->多个web ======>> 客户端--->Nginx--->(crm、oa、order、supplier等)
 
 ![dev-tech](https://github.com/kgtom/back-end/blob/master/pic/dev-tech.png)
 

 ## <span id="4">四、集群隔离</span>
 ### 1.背景
 随着系统的发展，单例服务无法满足需求，此时通过部署多个服务形成服务集群，来提升系统容量。
 ### 2.做法
 实质就是将调用频繁服务拆分，与其他服务分组隔离。例如：订单服务中有 订单列表、详情、下单、结账、配送、秒杀等服务。做秒杀活动时，我们需要将秒杀服务单独分成一个组，其它放在一个组，避免秒杀服务挂了后，影响其他服务。
 
 集群： 实例1 实例2
 实例1中部署秒杀服务
 实例2中部署其它服务
 
## <span id="5">五、机房隔离</span>
  随着系统高可用要求，会进行多个机房部署，每个机房服务都有自己的服务分组，本机房的服务应该只调用本机房服务，不进行跨机调用。
  一个机房发现问题时，可以通过DNS/负载均衡将请求切换到另一个机房，或者考虑服务能自动重试其它机房。
  
 ## <span id="6">六、读写隔离</span>
  主要说Redis主从模式将读写集群分离。读服务只从Redis获取，写服务来自主Redis。
 ## <span id="7">七、动静隔离</span>
 ### 1.背景
   例如订单详情页面访问量太大时，带宽被占满，这个时候css/js 会出现加载不全，甚至不能加载。因此需要将页面动态内容和静态内容分离。
 ### 2.做法
  一般做法，将静态内容放在CDN上，加速页面渲染。用户请求--->CDN--->Nginx--(静态资源)
  Nginx的proxy_cache和proxy_store真的很强大，利用proxy_store搭建图片服务器镜像实际上就相当于七牛和又拍的镜像CDN功能了，自动拉取图片保存在CDN服务器上。而proxy_cache作为Nginx缓存，既可以用作负载均衡，也可以反向绑定域名，真的很方便。[详情](https://www.freehao123.com/nginx-cdn/)
  
 ## <span id="8">八、爬虫隔离</span>
 
 
 ## <span id="9">九、热点隔离</span>
 
 ## <span id="10">十、资源隔离</span>
 
>Reference

* 开涛's《亿级流量网站架构核心技术》
