在两者出现之前是：单体应用，随着业务增加，不能满足需求，尤其是在代码维护、因为耦合度高，牵一发动全身，可扩展性不友好，所以逐渐 SOA和微服务出现了。
第一 两者比较
SOA：解决是企业高层业务领域的整合问题，例如： ERP、CRM、HR 系统通过ESB总线整合。

微服务：是SOA 一种实现。解决是企业下层具体业务的架构设计。
    优点：解决单体应用面临的问题，拆分业务系统，确定业务边界，组件化和服务化，API网卡类似于SOA的ESB企业总线，负责统一后台api入口、安全、路由过滤。
    缺点：分布式事务问题(CAP原则)及部署众多服务
    CAP理论的核心：一个分布式系统不可能同时很好的满足一致性，可用性和分区容错性这三个需求，最多只能同时较好的满足两个.
    通过 k8s(Rancher)+docker方式去做部署及服务发现、负载


第二如何拆分？
 1.why要拆分(拆分需求)？ 
 业务发生变化，新增新的业务，技术团队人员拆分；某个功能，一旦改变影响范围很大，需要拆分出来，单独做。
 2.拆分原则及方法？
 业务优先，兼顾技术；拆分不仅是业务梳理的过程，也是一种代码重构的过程，本着“高内聚、低耦合”(解耦)
 数据库拆分，明确业务边界，proxy-facade模式让代码更清晰，公共功能模块抽离；各服务之间通过 NSQ、GRPC通信。
 例如：订单模块，所有访问订单模块的数据，通过facade模式,隐藏实现细节，提供API，保证业务高内聚
               订单模块访问其它模块数据，通过proxy模式，不直接使用订单对象，降低了系统耦合度
               
第三 如何解决分布式事务？（不用分布式事务之前，让 下单和库存两者放在一个db中，使用本地事务。）

  1.使用消息系统(nsq、mq等)
   订单系统A---》 消息系统M  ---》 库存系统B 和记录已处理的订单C(两者一个事务)
   
讲解：A下单成功后，向M存储一笔信息，该消息通知B库存减少，通知B之前，
      先检查一下C中是否已经处理了过这个订单A的数量，如果没有处理，则处理B并且在C中加一笔数据，B和C一个事务中。
 2.
reference：
https://www.zhihu.com/question/37808426
github.com/hyperledger/fabric/core/chaincode/shim
               
 


